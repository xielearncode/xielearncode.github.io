<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/02/22/equals%E6%96%B9%E6%B3%95/"/>
    <url>/2022/02/22/equals%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>内部类</title>
    <link href="/2022/02/20/%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <url>/2022/02/20/%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><p>一个类的内部又完整嵌套了另一个类结构. 被嵌套的类称为<strong>内部类</strong>(inner class). 嵌套其他类的类又称为外部类(outer class). 是我们类的<strong>五大成员(属性, 方法, 构造器, 代码块, 内部类)</strong>. 内部类的最大特点就是可以直接访问私有属性, 并且可以体现类与类之间的包含关系.</p><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span>&#123;<span class="hljs-comment">//外部类</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123;<span class="hljs-comment">//内部类</span><br>        <br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Other</span>&#123;<span class="hljs-comment">//其他类</span><br>    <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="内部类的分类-4种"><a href="#内部类的分类-4种" class="headerlink" title="内部类的分类( 4种 )"></a>内部类的分类( 4种 )</h1><h3 id="定义在外部类局部位置上-比如方法内"><a href="#定义在外部类局部位置上-比如方法内" class="headerlink" title="定义在外部类局部位置上(比如方法内):"></a>定义在外部类<strong>局部</strong>位置上(比如方法内):</h3><ol><li>局部内部类(有类名)</li><li><strong>匿名内部类</strong>(没有类名, <strong>重点</strong>)  ( •̀ ω •́ )✧</li></ol><h3 id="定义在外部类的成员位置上"><a href="#定义在外部类的成员位置上" class="headerlink" title="定义在外部类的成员位置上:"></a>定义在外部类的成员位置上:</h3><ol><li>成员内部类(没有static修饰)</li><li>静态内部类(使用static修饰)</li></ol><h1 id="1-局部内部类"><a href="#1-局部内部类" class="headerlink" title="1. 局部内部类"></a>1. 局部内部类</h1><h3 id="局部内部类的使用"><a href="#局部内部类的使用" class="headerlink" title="局部内部类的使用"></a>局部内部类的使用</h3><blockquote><p>说明: <strong>局部内部类</strong>是定义在<strong>外部类的局部位置</strong>, 比如<strong>方法中,或者代码块中</strong>, 并且有类名</p></blockquote><ol><li>可以直接访问外部类的所有成员, 包含私有的<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span>&#123;<span class="hljs-comment">//外部类</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> n1  <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m1</span><span class="hljs-params">()</span>&#123;<span class="hljs-comment">//方法</span><br>        <span class="hljs-comment">//1.局部内部类是定义在外部类的局部位置, 通常都是方法中</span><br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123;<span class="hljs-comment">//局部内部类</span><br>            <span class="hljs-comment">//可以直接访问外部内的所有成员,包含私有的</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f1</span><span class="hljs-params">()</span>&#123;<span class="hljs-comment">//内部类方法</span><br>                System.out.println(n1);<span class="hljs-comment">//这里不会报错</span><br>                m2();<span class="hljs-comment">//也不会报错</span><br>            &#125;<br>        &#125;<br>     <br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>不能添加访问修饰符, 因为它的地位就是一个局部变量. 局部变量是不能使用修饰符的. 但是可以用final修饰, 因为局部变量也可以使用final</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>()&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span>;<span class="hljs-comment">//这里会报错,因为使用了public修饰局部内部类</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span>;<span class="hljs-comment">//这里语法正确</span><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner_001</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Inner</span>&#123;<br><span class="hljs-comment">//这一句语法是正确的, 只要Inner没有被final修饰</span><br>&#125;<br><br><span class="hljs-comment">//局部内部类就相当于一个局部变量, 作用域只在被定义的方法体内</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li><p>作用域: 仅仅在定义它的<strong>方法或者代码块中</strong></p><p>局部内部类就相当于一个局部变量, 作用域只在被定义的方法体内</p></li><li><p>局部内部类访问外部类成员[访问方式: 直接访问]</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span><span class="hljs-number">12</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> n1;<span class="hljs-comment">//直接访问外部类的成员</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>外部类访问局部类成员[访问方式:<strong>创建对象, 再访问</strong>, <strong>必须在作用域内</strong>]</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span>&#123;<br><span class="hljs-type">int</span> n;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123;<br><span class="hljs-type">int</span> n1;<br>&#125;<br><br>    <span class="hljs-type">Inner</span> <span class="hljs-variable">inner001</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();<br>    inner001.n1;<span class="hljs-comment">//外部类访问内部类成员, 需要创建对象</span><br>    <span class="hljs-comment">//而且必须在内部类的作用域内, 比如这里必须在m()方法内才能创建内部类对象</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>记住<strong>三点</strong></p><ol><li><strong>局部内部类定义</strong>在<strong>方法或者代码块</strong>中</li><li><strong>作用域</strong>在方法体或者代码块中</li><li><strong>本质</strong>仍然是一个类</li></ol><h3 id="局部内部类的其他细节"><a href="#局部内部类的其他细节" class="headerlink" title="局部内部类的其他细节"></a>局部内部类的其他细节</h3><ol><li><strong>外部其他类不能访问局部内部类</strong>(因为局部内部类是一个局部变量)</li><li>如果外部类和局部内部类的成员<strong>重名时</strong>,遵循<strong>就近原则</strong>, 如果想访问外部类的成员, 则可以使用(<strong>外部类名.this.成员名</strong>)去访问</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">&quot;外部类的 n = &quot;</span> + Outer.<span class="hljs-built_in">this</span>.n);<br></code></pre></td></tr></table></figure><blockquote><p>原因: 这里的<code>Outer.this</code> 本质是外部类Outer的一个对象, 哪个对象调用的这个使用了<code>Outer.this</code>的内部类所在的方法, 那么这个<code>Outer.this</code>就指向这个调用该方法的对象.</p><p>比如建立了一个<code>Outer</code>对象<code>outer001</code>, 这个<code>outer001</code>调用了<code>m()</code>方法, <code>m()</code>方法中有内部类<code>Inner</code> ,<code>Inner</code>内部又有<code>Outer.this</code>, 那么这个<code>Outer.this</code>则指向<code>outer001</code></p></blockquote><h1 id="2-匿名内部类"><a href="#2-匿名内部类" class="headerlink" title="2. 匿名内部类"></a>2. 匿名内部类</h1><blockquote><p>说明:匿名内部类是定义在外部类的<strong>局部位置</strong>, 比如方法中, 并且<strong>没有类名</strong></p></blockquote><h3 id="匿名内部类的使用-基于接口-—-实现接口"><a href="#匿名内部类的使用-基于接口-—-实现接口" class="headerlink" title="匿名内部类的使用(基于接口)    —-  实现接口"></a>匿名内部类的使用(基于接口)    —-  实现接口</h3><blockquote><ol><li>本质是类</li><li>内部类</li><li>该类没有名字(系统取名, 用户不定义其名字)</li><li>同时还是一个对象</li></ol></blockquote><ol><li>匿名内部类的基本语法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> 类或接口(参数列表)&#123;<br>    类体<br>&#125;;<span class="hljs-comment">//分号不能少, 这里整体相当于一个语句</span><br></code></pre></td></tr></table></figure><p>使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m</span><span class="hljs-params">()</span>&#123;<span class="hljs-comment">//方法</span><br>        <span class="hljs-comment">//基于接口的匿名内部类</span><br>        <span class="hljs-comment">//1. 需求: 想使用IA接口, 并创建对象</span><br>        <span class="hljs-comment">//2. 传统方式: 写一个类, 实现该接口, 并创建对象</span><br>        <span class="hljs-type">IA</span> <span class="hljs-variable">tiger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Tiger</span>();<br>        tiger.cry();<br>        <br>        <span class="hljs-comment">//3. tiger只想使用一次呢? 上述方式有点啰嗦,假如又狗猫什么很多动物, 这样定义是很烦的</span><br>        <span class="hljs-comment">//4. 因此可以使用匿名内部类来简化开发</span><br>        <br>       <span class="hljs-type">IA</span> <span class="hljs-variable">tiger</span> <span class="hljs-operator">=</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">IA</span>()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cry</span><span class="hljs-params">()</span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;老虎叫&quot;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//这里就不用再单独创建一个Tiger类了, 直接使用的匿名内部类</span><br>        <br>        <br>    &#125;<br>    <br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IA</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cry</span><span class="hljs-params">()</span>;<br>&#125;<br><br><br><span class="hljs-comment">//实现接口,创建对象, 不使用匿名内部类的时候, 就需要创建一个类并实现IA接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tiger</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IA</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cry</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;嗷呜~~~~~~~&quot;</span>)<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>看底层, 匿名内部类的实质</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">XXXX</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IA</span>&#123;<br>    ...<br>&#125;<br>XXXX是系统分配的, 外部类+$分配数字,  如上述代码的名字为Outer$<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>匿名内部类虽然只使用一次, 但是创建的对象可以多次使用</strong></p><p>如上述的Outer$1不能再使用了, 但是tiger可以再次使用</p><h3 id="匿名内部类的使用-基于类-——-实现继承"><a href="#匿名内部类的使用-基于类-——-实现继承" class="headerlink" title="匿名内部类的使用(基于类)    ——-  实现继承"></a>匿名内部类的使用(基于类)    ——-  实现继承</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">//基于类的匿名内部类</span><br>        <span class="hljs-type">Father</span> <span class="hljs-variable">father</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Father</span>(<span class="hljs-string">&quot;jack&quot;</span>)&#123;<br>            <span class="hljs-comment">//参数列表 传送给Father的构造器, 匿名内部类一般不建立自己的构造器</span><br>            <span class="hljs-comment">//这里的运行类型是匿名内部类Test$1, 不是Father</span><br>            <br>        &#125;;<span class="hljs-comment">//分号不能少, 这是一个语句</span><br>        <br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">这里的匿名内部类本质是:</span><br><span class="hljs-comment">class Test$1 extends Father&#123;// 继承Father类</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">&#125;Test$1 是在类Test内的内部类</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Father</span><span class="hljs-params">(String name)</span>&#123;<br>        <br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>匿名内部类的语法比较奇特, 因为匿名内部类<strong>既是一个类的定义</strong>, <strong>同时它本身也是一个对象</strong>, 因此从语法上来看, 它既有定义类的特征, 也有创建对象的特征</p><p>因此可以直接调用, 匿名内部类本身也是返回对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hi</span><span class="hljs-params">()</span>&#123;<br>        ...<br>    &#125;<br>&#125;.hi();<br></code></pre></td></tr></table></figure><ul><li>可以直接访问外部类的所有成员, 包含私有的</li><li>不能添加访问修饰符, 因为它的地位就是一个局部变量</li><li><strong>作用域: 仅仅在它的方法或代码块中</strong></li><li>匿名内部类访问外部成员是直接访问的</li><li>外部其他类不能访问匿名内部类(因为匿名内部类是一个局部变量)</li><li>如果外部类和内部类的成员重名时, 内部类访问时遵循就近原则, 若要访问外部类, 则使用( 外部类名.this.成员) 访问, 方法同局部内部类</li></ul><h3 id="匿名内部类的最佳实践"><a href="#匿名内部类的最佳实践" class="headerlink" title="匿名内部类的最佳实践"></a>匿名内部类的最佳实践</h3><ul><li>当做实参直接传递, 简洁高效</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//当作实参直接传递, 简洁高效</span><br>        <span class="hljs-comment">//本质传递了一个对象, 而且这个对象实现了IL接口</span><br>        f1(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IL</span>()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;直接在方法的参数列表&quot;</span>);<br>            &#125;<br>        &#125;);<span class="hljs-comment">//分号不可少,因为这是一个语句</span><br>    &#125;<br>    <br>    <span class="hljs-comment">//静态方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f1</span><span class="hljs-params">(IL il)</span>&#123;<br>        il.show();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IL</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>课堂练习</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hspedu.InnerClass;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 蓝鸟x</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Anonymous</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">CellPhone</span>().alarmClock(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Bell</span>()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ring</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;懒狗起床了&quot;</span>);<br>            &#125;<br><br>        &#125;);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">CellPhone</span>().alarmClock(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Bell</span>()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ring</span><span class="hljs-params">()</span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;上课了&quot;</span>);<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Bell</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">ring</span><span class="hljs-params">()</span>;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CellPhone</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">alarmClock</span><span class="hljs-params">(Bell bell)</span>&#123;<br>        bell.ring();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>包含的知识点: </p><ol><li>继承</li><li>多态</li><li>动态绑定</li><li>内部类</li></ol></blockquote><h1 id="3-成员内部类"><a href="#3-成员内部类" class="headerlink" title="3. 成员内部类"></a>3. 成员内部类</h1><blockquote><p>说明:成员内部类是<strong>定义在外部类的成员位置</strong>, 并且<strong>没有static修饰</strong></p></blockquote><ul><li>可以直接访问外部类的所有成员, 包含私有的</li><li>可以添加任意访问修饰符(public, protected, 默认, private), 因为<strong>它的地位就是一个成员</strong></li><li>作用域和其他外部类的其他成员一样, 为整个类体. </li><li>成员内部类访问外部类成员时, 直接访问</li><li>外部类访问内部类成员, 先创建内部类对象, 再访问</li><li>外部其他类访问成员内部类(三种方式):</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span> Outer.<span class="hljs-type">Inner</span> <span class="hljs-variable">inner001</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>().<span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();<span class="hljs-comment">//new Inner()当作new Outer()的成员</span><br><span class="hljs-number">2.</span> 在外部内定义一个getInner()方法, 可以返回内部类对象<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123;<br><br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> Inner <span class="hljs-title function_">getInner</span><span class="hljs-params">()</span>&#123;<span class="hljs-comment">//需要参数加参数即可</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();<br>    &#125;<br>&#125;<br><span class="hljs-number">3.</span> 本质同方式<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><ul><li>如果外部类和内部类成员重名的时候, 内部类访问的话, 默认遵循就近原则, 如果想访问外部类的成员, 可以使用(外部类名.this.成员)去访问</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span>&#123;<br>            n2 = Outer.<span class="hljs-built_in">this</span>.n2;<span class="hljs-comment">//部类名.this.成员</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h1><blockquote><p>说明: 静态内部类是定义在外部类的成员位置, 并且有static修饰</p></blockquote><ul><li>可以直接访问外部类的所有静态成员, 包含私有的, 但<strong>不能直接访问非静态成员</strong> → 可以通过创建外部类对象去访问</li><li>可以添加任意访问修饰符(public private 默认 protected). 因为<strong>它的位置就是一个成员</strong></li><li>作用域: 和其他成员一样, 为整个类体</li><li>静态内部类<strong>直接访问外部类静态成员</strong></li><li>访问非静态类时, 先创建外部类对象, 再访问</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span>&#123;<br>    <span class="hljs-keyword">public</span>  <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123;<br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span>&#123;<br>            <span class="hljs-type">Outer</span> <span class="hljs-variable">outer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> outer.n;<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>外部其他类访问静态内部类, 只要静态内部类不被private修饰就能直接访问</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>.Inner();<br><span class="hljs-number">2.</span> 外部类设置一个get方法返回Inner对象<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();<br></code></pre></td></tr></table></figure><ul><li>如果外部类和静态内部类的成员变量重名时, 静态内部类访问时, 默认遵循就近原则, 如果想访问外部类成员, 则可以使用(外部类名.成员) 去访问</li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ol><li><p>内部类有四种: <strong>局部内部类  匿名内部类  成员内部类  静态内部类</strong></p></li><li><p>重点掌握<strong>匿名内部类</strong></p><p>new 类&#x2F;接口(参数列表){};  &#x2F;&#x2F;分号不能少</p></li><li><p>成员内部类, 静态内部类 是放在外部类的成员位置, 本质是一个成员</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
      <tag>面向对象部分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>枚举类</title>
    <link href="/2022/02/20/%E6%9E%9A%E4%B8%BE%E7%B1%BB%20enum/"/>
    <url>/2022/02/20/%E6%9E%9A%E4%B8%BE%E7%B1%BB%20enum/</url>
    
    <content type="html"><![CDATA[<h1 id="枚举类-enum"><a href="#枚举类-enum" class="headerlink" title="枚举类 enum"></a>枚举类 enum</h1><blockquote><p>本文章是通过学习B站视频<a href="https://www.bilibili.com/video/BV1fh411y7R8?p=425">【零基础 快速学Java】韩顺平 零基础30天学会Java_哔哩哔哩_bilibili</a>写的笔记</p><p align="right">2022/2/20</p></blockquote><p>😃给自己的代码加头</p><p><img src="https://img-blog.csdnimg.cn/80e0adcdf52d423b923941f476de04c8.png" alt="操作流程"></p><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>当有多个固定的对象需要定义时, 如果每一个对象都要新建, 例如对于季节类, 需要春夏秋冬四个对象, 而按照之前所学内容, 要用户来创建对象, 那么四个季节就不固定. 季节只有四个, 用户定义没限制. 枚举类型是把具体的对象一个一个列举出来的类,因此季节可用枚举类来设计季节类</p><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>枚举是一组常量的集合. 可以理解为: 枚举属于<strong>一种特殊的类</strong>, 里面只包含一组有限的特定的对象</p><h2 id="自定义枚举流程"><a href="#自定义枚举流程" class="headerlink" title="自定义枚举流程"></a>自定义枚举流程</h2><ol><li>使用关键字<code>enum</code> 替代 <code>class</code></li><li>定义常量, 例如: <strong>本质</strong>是<code>public static final Season SPRING = new Season(&quot;Spring&quot;, &quot;warm&quot;); </code>可以直接用<code>SPRING(&quot;Spring&quot;, &quot;warm&quot;)</code> 替代. 解读: <code>常量名( 实参列表...)</code></li><li>如果有<strong>多个常量, 使用 <code>,</code> 间隔</strong>即可. 例如<code>SPRING(&quot;Spring&quot;, &quot;warm&quot;), SUMMER(&quot;Summer&quot;, &quot;hot&quot;);</code> </li><li>🐳🐳🐳使用enum来实现枚举, 要求将定义的常量<strong>写在最前面</strong></li></ol><h2 id="enum关键字实现枚举注意事项"><a href="#enum关键字实现枚举注意事项" class="headerlink" title="enum关键字实现枚举注意事项"></a><code>enum</code>关键字实现枚举注意事项</h2><ol><li>当我们使用enum关键字来开发一个枚举类时, 默认会继承Enum类, 这里使用javap工具来进行反编译验证<br><img src="https://img-blog.csdnimg.cn/e3ee96f82e8a4053ae0b0a10c6e02951.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6JOd6bifeA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs java">Compiled from <span class="hljs-string">&quot;Enumeration01.java&quot;</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">com</span>.hspedu.enum_.Season2 <span class="hljs-keyword">extends</span> <span class="hljs-title class_">java</span>.lang.Enum&lt;com.hspedu.enum_.Season2&gt; &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> com.hspedu.enum_.Season2 SPRING;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> com.hspedu.enum_.Season2 SUMMER; <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> com.hspedu.enum_.Season2 AUTUMN; <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> com.hspedu.enum_.Season2 WINTER; <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> com.hspedu.enum_.Season2[] values(); <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> com.hspedu.enum_.Season2valueOf(java.lang.String); <br><span class="hljs-keyword">public</span> java.lang.String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>; <br><span class="hljs-keyword">public</span> java.lang.String <span class="hljs-title function_">getDesc</span><span class="hljs-params">()</span>; <br><span class="hljs-keyword">public</span> java.lang.String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span>; <br><span class="hljs-keyword">static</span> &#123;&#125;; <br>&#125;<br></code></pre></td></tr></table></figure></li><li>传统的 public static final Season2 SPRING &#x3D; new Season2(“春天”, “温暖”); 简化成SPRING(“春天”, “温暖”); 这里要明白它调用的哪个构造器.  格式: <strong>对象名(实参列表)</strong>, 这里实参列表是<strong>传给构造器的</strong> </li><li>如果使用无参构造器, 创建枚举对象, 则<strong>实参列表和小括号都可以省略(省不省略都可以)</strong> </li><li>当<strong>有多个枚举对象的时候,使用’ , ‘ 间隔,</strong> 最后一个用分号结尾 枚举对象必须放在枚举类的行首</li></ol><h2 id="课堂练习"><a href="#课堂练习" class="headerlink" title="课堂练习"></a>课堂练习</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Gender</span>&#123;<br>BOY, GIRL;<br>&#125;<br></code></pre></td></tr></table></figure><p>正确的写法, 调用无参构造器, 对象名是BOY, 和GIRL. 这里对象名就是常量名, 一般枚举类内部定义的变量后续操作不可更改, 视为常量.</p><h2 id="enum常用方法说明"><a href="#enum常用方法说明" class="headerlink" title="enum常用方法说明"></a>enum常用方法说明</h2><blockquote><p>原理: 使用enum时, 会所建类会隐式继承Enum类, 这样我们就可以使用Enum类相关的方法<br>**对象名.name(); **输出对象的名字<br>**对象名.ordinal();**输出对象的编号,从0开始<br><strong>类名.values();</strong> 返回枚举类定义的所有对象, 返回的是一个数组<br>新知识点: 增强for循环, <code>for(Season2 season : values)&#123;&#125;</code>&#x2F;每次循环将数组的一个元素传入到season, 没有了就退出<br>**类名.valueOf()**将字符串转化为枚举对象, 要求字符串必须为已有的常量名, 否则报错</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.根据输入的名称&quot;SPRING&quot;到Season2的枚举类对象去查找,找到了就返回给spring1对象,否则报错</span><br>Season2  spring1=Season2.valueOf(<span class="hljs-string">&quot;SPRING&quot;</span>);<br></code></pre></td></tr></table></figure><p>且返回类型的对象引用类型, 即运行类型的地址</p><p><strong>compareTo</strong> 比较两个枚举常量(对象), 比较的是编号对应values</p><h2 id="enum实现接口"><a href="#enum实现接口" class="headerlink" title="enum实现接口"></a>enum实现接口</h2><p>使用enum关键字后, 所创建的类不能再继承其他类了, 因为enum会隐式继承Enum, 而java是单继承机制<br>枚举类和普通类一样, 可以实现接口, 如下格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> 类名 implements 接口<span class="hljs-number">1</span>, 接口<span class="hljs-number">2</span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><table><tr><td bgcolor=#bfe1f1>以上就是enum类的全部内容了, 有不正确的地方欢迎大佬指正, 在下是编程小白蓝鸟x</td></tr></table>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用两个栈实现队列</title>
    <link href="/2022/02/20/%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <url>/2022/02/20/%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h2><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 <code>appendTail</code> 和 <code>deleteHead</code> ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，<code>deleteHead</code> 操作返回 -1 </p><p>示例1:</p><figure class="highlight prolog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs prolog">输入：<br>[<span class="hljs-string">&quot;CQueue&quot;</span>,<span class="hljs-string">&quot;appendTail&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>]<br>[[],[<span class="hljs-number">3</span>],[],[]]<br>输出：[null,null,<span class="hljs-number">3</span>,<span class="hljs-number">-1</span>]<br></code></pre></td></tr></table></figure><p>示例2:</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：<br>[<span class="hljs-string">&quot;CQueue&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>,<span class="hljs-string">&quot;appendTail&quot;</span>,<span class="hljs-string">&quot;appendTail&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>]<br>[[],[],[<span class="hljs-number">5</span>],[<span class="hljs-number">2</span>],[],[]]<br>输出：[null,<span class="hljs-number">-1</span>,null,null,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><p>思路:</p><blockquote><p>维护两个栈，第一个栈支持插入操作，第二个栈支持删除操做. 插入操作时, 数据元素先被顺序插入第一个栈, 随后再从第一个栈取出插入到第二个栈, 最后从第二个栈一一删除</p></blockquote><p><img src="https://img-blog.csdnimg.cn/f1ebe6b526934309b05440a03f979dde.gif" alt="在这里插入图片描述"></p><p>代码: </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">CQueue</span> &#123;<br>    Deque&lt;Integer&gt; stack1;<br>    Deque&lt;Integer&gt; stack2;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CQueue</span>()</span> &#123;<br>        stack1 = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();<br>        stack2 = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">appendTail</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span></span>)</span> &#123;<br>        stack1.push(<span class="hljs-keyword">value</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">deleteHead</span>()</span> &#123;<br>        <span class="hljs-comment">// 第二个栈为空时, 执行数据元素从栈1向栈2转移</span><br>        <span class="hljs-keyword">if</span> (stack2.isEmpty()) &#123;<br>            <span class="hljs-keyword">while</span> (!stack1.isEmpty()) &#123;<br>                stack2.push(stack1.pop());<br>            &#125;<br>        &#125; <br>        <span class="hljs-comment">//转移完毕后, 栈2仍然为空返回-1, 否则将栈2元素一一删除</span><br>        <span class="hljs-keyword">if</span> (stack2.isEmpty()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">int</span> deleteItem = stack2.pop();<br>            <span class="hljs-keyword">return</span> deleteItem;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度分析时间复杂度为O(1), 空间复杂度为O(n)</p>]]></content>
    
    
    <categories>
      
      <category>剑指offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>房屋出租系统(初级)</title>
    <link href="/2022/02/17/%E6%88%BF%E5%B1%8B%E5%87%BA%E7%A7%9F%E7%B3%BB%E7%BB%9F(%E5%88%9D%E7%BA%A7)/"/>
    <url>/2022/02/17/%E6%88%BF%E5%B1%8B%E5%87%BA%E7%A7%9F%E7%B3%BB%E7%BB%9F(%E5%88%9D%E7%BA%A7)/</url>
    
    <content type="html"><![CDATA[<p>本项目是根据<a href="https://www.bilibili.com/video/BV1fh411y7R8?p=362">【零基础 快速学Java】韩顺平 零基础30天学会Java_哔哩哔哩_bilibili</a> 课程进行的。项目的主要目的是巩固一下以前学习的 Java基础 知识。</p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>​    实现基于文本界面的房屋出租系统，能够实现对房屋信息的添加，修改和删除（用数组实现），并且能够打印房屋明细表。</p><h2 id="界面"><a href="#界面" class="headerlink" title="界面"></a>界面</h2><ul><li>主菜单<ol><li>新 增 房 源</li><li>查 找 房 屋</li><li>删 除 房 屋</li><li>修 改 房 屋 信 息</li><li>房 屋 列 表</li><li>退           出</li></ol></li><li>新增房源<ul><li>姓名：</li><li>电话：</li><li>地址：</li><li>月租：</li><li>状态（未出租&#x2F;已出租）:</li></ul></li><li>查找房源<ul><li>请输入查找的id：</li><li>有id    姓名   电话   地址   租金   状态</li></ul></li><li>删除房源<ul><li>选择要删除的房屋编号</li><li>再次确认</li></ul></li><li>修改房源<ul><li>选择房屋编号</li><li>列出修改的信息（不修改的地方直接回车）</li></ul></li><li>退出系统<ul><li>再次确认</li><li>输出：你退出了程序~~~</li></ul></li></ul><h2 id="项目设计-程序框架"><a href="#项目设计-程序框架" class="headerlink" title="项目设计-程序框架"></a>项目设计-程序框架</h2><p><img src="https://img-blog.csdnimg.cn/1c3e603acc7443fcb8fb49cd5cac7c34.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6JOd6bifeA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="房屋出租系统框架图"></p><p>上图每一个类对应一个包，便于管理。虽然最初设计时只有一个类或者一个文件，但是随着项目后续的完善，所对应的相关类有很多，因此这里的每个类对应一个包。上述图片用<a href="https://www.iodraw.com/diagram/">ioDraw</a>绘制</p><h4 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h4><p>实际开发中，公司都会提供对应的工具类和开发库，可以提高开发效率。因此在日常学习中要能够看懂别人写的代码，并正确调用</p><p>这里的 <code>utility</code> 类是课程提供的,  可在<a href="https://blog.csdn.net/m0_52228020/article/details/120975203">(16条消息) 韩顺平Utility工具类(java房屋出租项目)_m0_52228020的博客-CSDN博客</a>复制到自己的项目里.</p><h4 id="House类"><a href="#House类" class="headerlink" title="House类"></a>House类</h4><p>House类的属性有 编号, 房主, 电话, 地址, 月租, 状态. House的对象表示一个房屋信息</p><p>将各属性写入House类, 并且设立相应的构造器与 setter 与 getter 方法, 为了方便输出对象信息, 还应该实现toString 方法的重写</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> id +<br>            <span class="hljs-string">&quot;\t&quot;</span> + name + <br>            <span class="hljs-string">&quot;\t&quot;</span> + phone +<br>            <span class="hljs-string">&quot;\t&quot;</span> + address +<br>            <span class="hljs-string">&quot;\t&quot;</span> + rent +<br>            <span class="hljs-string">&quot;\t&quot;</span> + state;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="HouseView类-与-HouseService类"><a href="#HouseView类-与-HouseService类" class="headerlink" title="HouseView类 与 HouseService类"></a>HouseView类 与 HouseService类</h4><p>HouseView类用于显示，HouseService类用于给HouseView类传输相应的数据，如HouseView中有listHouse()方法，而HouseService中的list()方法用于给listHouse()方法传送房屋列表的信息.  个人理解: HouseView相当于前端, HouseService相当于后端.</p><ol><li>实现主菜单和完成退出软件的功能</li></ol><p>说明：实现功能的三步曲[明确功能 –&gt; 思路分析 –&gt; 代码实现]</p><ul><li><p>功能说明:</p><p>用户打开软件, 可以看见主菜单, 可退出软件</p></li><li><p>思路分析:</p><p>在HouseView.java中, 编写一个方法mainMenu, 显示菜单.</p></li><li><p>实现效果</p><blockquote><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;房屋出租系统菜单&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>       1 新 增 房 源<br>       2 查 找 房 源<br>       3 删 除 房 源 信 息<br>       4 修 改 房 源 信 息<br>       5 房 屋 列 表<br>       6 退      出<br>       7 新增房源<br>请输入你的选择(1 ~ 6):<br>1<br>新 增</p></blockquote></li></ul><ol start="2"><li><p>完成显示房屋列表的功能</p><ul><li><p>功能说明: 显示房屋列表的各个信息</p></li><li><p>思路分析: 需要编写HouseView.java 和 HouseService.Java</p><p>在显示房屋列表时, 如果总房源数小于数组容量, 应该设置 break 语句, 防止输出空指针</p></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listHouses</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;===================房屋列表==================&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;编号\t\t房主\t\t电话\t\t地址\t\t月租\t\t状态(未出租/已出租)&quot;</span>);<br>        House[] houses = houseService.list();<span class="hljs-comment">//得到房屋信息</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; houses.length; i++) &#123;<span class="hljs-comment">//   1.这里不因该用houses.length, 因为houses是能表示的房屋总数, 实际存在的房屋因该另外设置变量</span><br>            <span class="hljs-comment">//2. 或者加一个判断</span><br>            <span class="hljs-keyword">if</span>(houses[i] == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            System.out.println(houses[i]);  <span class="hljs-comment">//这里输出房屋的基本信息, 默认输出调用的是toString方法</span><br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;===================房屋列表显示完毕==================&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li><p>实现效果</p><blockquote><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;     房 屋 列 表       &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>编号        房主        电话        地址        月租        状态(未出租&#x2F;已出租)<br>1        jack    113        海定区    2000    未出租<br>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;房屋列表显示完毕&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p></blockquote></li><li><p>添加房屋信息功能</p><ul><li><p>功能说明与思路分析</p><p>在HouseView设置addHouse()方法, 用于前端显示. 在HouseService中添加 add()方法, 用于添加房屋信息, 并返回boolean值</p><p>在HouseService中设置houseNums的整型变量来记录当前房屋信息, 并通过如下方式将创建的房屋对象加入到数组中.</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">houses[houseNums++] = newHouse;<span class="hljs-comment">// 把newHouse信息加入到数组</span><br></code></pre></td></tr></table></figure><p>在HouseService中设置idCounter的整型变量来记录当前房屋id增长到哪一个值了, 并通过如下的方式来更新新加入的房屋id(创建房屋对象时设置的id为0(任意值均可,反正会修改)).</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">newHouse.setId(++idCounter);<span class="hljs-comment">//更新newHouse的id</span><br></code></pre></td></tr></table></figure><p>添加房屋信息时实现了对House数组的扩容机制, 方法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * House数组扩容,每次增加10个</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> houses</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> House[] addLengthArray(House[] houses)&#123;<br>    House[] houses1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">House</span>[houses.length + <span class="hljs-number">10</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; houses.length; i++) &#123;<span class="hljs-comment">//一一复制</span><br>        houses1[i] = houses[i];<br>    &#125;<br>    <span class="hljs-comment">//houses = houses1;</span><br>    <span class="hljs-keyword">return</span> houses1;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>addLengArray() 方法位于HouseService类中</p></blockquote><ul><li><p>实现效果</p><blockquote><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;  添 加 房 屋  &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>姓名: jack<br>電話: 112<br>地址: China<br>月租: 3000<br>状态(已出租&#x2F;未出租): 已出租<br>“&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;  添加房屋成功  &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;”</p></blockquote></li><li><p>删除房源</p><ul><li><p>功能说明: </p><p>用户输入待删除的房屋编号, 并二次确认, 然后系统删除该id对应的房屋信息. 当该id不存在时, 系统应该提示删除失败</p></li><li><p>思路分析</p><p>编写HouseView和HouseService方法</p></li><li><p>HouseService中的del方法</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">del</span><span class="hljs-params">(<span class="hljs-type">int</span> delId)</span>&#123;<br>       <span class="hljs-comment">//先找出对应的id的房屋信息对应的编号</span><br>       <span class="hljs-comment">//注意编号和id是不一样的</span><br>       <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">//作为哨兵</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; houseNums; i++) &#123;<br>           <span class="hljs-keyword">if</span>(delId == houses[i].getId())&#123;<span class="hljs-comment">//房屋id与i对应的id相同时</span><br>               index = i; <span class="hljs-comment">//用index记录i</span><br>               <br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">if</span>(index == -<span class="hljs-number">1</span>)&#123;<br>           <span class="hljs-comment">//index没变, 说明数组中不存在此id</span><br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>       &#125;<br>       <span class="hljs-comment">//如果找到, 后面对象前移覆盖要删除的房屋对象</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index; i &lt; houseNums - <span class="hljs-number">1</span>; i++) &#123;<span class="hljs-comment">//num从1开始,而下标从0开始</span><br>           houses[i] = houses[i+<span class="hljs-number">1</span>];<br>           <br>       &#125;<br>       houses[--houseNums] = <span class="hljs-literal">null</span>;  <span class="hljs-comment">//--houseNums对应最后一个房屋信息, 正好也把houseNums减1</span><br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><ul><li>HouseView中的delId方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//编写delHouse() 接收输入的id, 调用HouseService的del方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delHouse</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;===================  删除房屋信息  ==================&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;请输入待删除房屋的id(-1)表示退出:&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">delId</span> <span class="hljs-operator">=</span> Utility.readInt();<br>        <span class="hljs-keyword">if</span>(delId == -<span class="hljs-number">1</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;=================  放弃删除房屋信息  ==================&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>      <span class="hljs-comment">//  System.out.println(&quot;请确认是否删除(Y/N), 请小心选择:&quot;);</span><br>        <span class="hljs-type">char</span> <span class="hljs-variable">choice</span> <span class="hljs-operator">=</span> Utility.readConfirmSelection();<span class="hljs-comment">//该方法本身就有循环逻辑</span><br>        <span class="hljs-keyword">if</span>(choice == <span class="hljs-string">&#x27;Y&#x27;</span>)&#123;<br>            <span class="hljs-comment">//真的删除</span><br>            <span class="hljs-keyword">if</span>(houseService.del(delId))&#123;<br>                System.out.println(<span class="hljs-string">&quot;=================  删除房屋信息成功  ==================&quot;</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;=================  删除房屋信息编号不存在  ==================&quot;</span>);<br>            &#125;<br><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;=================  放弃删除房屋信息  ==================&quot;</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li><p>退出确认机制</p><ul><li>使用Utility提供的方法, 完成确认</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这里使用Utility提供的方法, 完成退出确认</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exit</span><span class="hljs-params">()</span>&#123;<br>      <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Utility.readConfirmSelection();<br>      <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;Y&#x27;</span>)&#123;<br>          loop = <span class="hljs-literal">false</span>;<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><ul><li><p>根据id查找房屋信息</p><ul><li><p>功能说明:</p><p>根据用户输入的id, 查找出已有房源. 先确认输入的信息有效, 如果能找到则显示, 找不到就报错</p></li><li><p>思路分析</p><p>需要同时编写HosueView类, 和HosueService类. 实现houseSerch与Serch方法</p></li><li><p>小小bug</p><p>这里发现了一个Utility的bug, 当我在readInt() 前面没有输出信息的时候, 程序就会卡在这里不动, 即便我回车也没有继续执行, 希望有大佬指点一二.</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">houseFind</span><span class="hljs-params">()</span>&#123;<br>        System.out.print(<span class="hljs-string">&quot;请输入要查找的房屋id:&quot;</span>);<span class="hljs-comment">//当没有这一条语句时, 下一条语句无法跳出</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">findId</span> <span class="hljs-operator">=</span> Utility.readInt();<span class="hljs-comment">//Utility是上文提供的工具类</span><br><br>        <span class="hljs-type">House</span> <span class="hljs-variable">tempHouse</span> <span class="hljs-operator">=</span> houseService.find(findId);<br><br>        <span class="hljs-keyword">if</span>(tempHouse == <span class="hljs-literal">null</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;不存在此id的房屋&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        System.out.println(tempHouse);<br>    &#125;<br></code></pre></td></tr></table></figure><p>bug已解决, 是我突然降智了, 哈哈哈.</p><ul><li><p>修改房屋信息</p><ul><li><p>功能说明: 先让用户输入需要修改的房屋id, 再通过此id查找到对应房屋, 并对其信息进行修改</p></li><li><p>思路分析:需要同时编写HosueView类, 和HosueService类. 实现modifyHouse与modify方法</p></li><li><p>特别说明:</p><p>因为houseService.find()  返回的是引用类型, 因此对其返回对象的修改其实是修改houses数组里对应的House对象</p></li><li><p>代码如下:</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 修改房屋信息</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modifyHouse</span><span class="hljs-params">()</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;==================修改房屋信息=================&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;请选择待修改的房屋编号(-1表示退出)&quot;</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">modifyId</span> <span class="hljs-operator">=</span> Utility.readInt();<br>   <span class="hljs-comment">// houseService.modify(modifyId);</span><br>    <span class="hljs-keyword">if</span>(modifyId == -<span class="hljs-number">1</span>)&#123;<br>        System.out.println(<span class="hljs-string">&quot;你放弃了房屋修改&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br><br>    &#125;<br>    <span class="hljs-type">House</span> <span class="hljs-variable">modifyHouse</span> <span class="hljs-operator">=</span> houseService.find(modifyId);<br>    <span class="hljs-keyword">if</span>(modifyHouse == <span class="hljs-literal">null</span>)&#123;<br>        System.out.println(<span class="hljs-string">&quot;该id对应的房屋信息不存在&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    System.out.print(<span class="hljs-string">&quot;姓名(&quot;</span>+modifyHouse.getName() +<span class="hljs-string">&quot;):&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> Utility.readString(<span class="hljs-number">8</span>,modifyHouse.getName());<br>    <span class="hljs-keyword">if</span>(!modifyHouse.getName().equals(name))&#123;<br>        modifyHouse.setName(name);<br>    &#125;<br>    System.out.print(<span class="hljs-string">&quot;电话(&quot;</span>+modifyHouse.getPhone() +<span class="hljs-string">&quot;):&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> Utility.readString(<span class="hljs-number">12</span>,modifyHouse.getPhone());<br>    <span class="hljs-keyword">if</span>(!modifyHouse.getPhone().equals(phone))&#123;<br>        modifyHouse.setPhone(phone);<br>    &#125;<br>    System.out.print(<span class="hljs-string">&quot;地址(&quot;</span>+modifyHouse.getAddress() +<span class="hljs-string">&quot;):&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">address</span> <span class="hljs-operator">=</span> Utility.readString(<span class="hljs-number">18</span>,modifyHouse.getAddress());<br>    <span class="hljs-keyword">if</span>(!modifyHouse.getAddress().equals(address))&#123;<br>        modifyHouse.setAddress(address);<br>    &#125;<br>    System.out.print(<span class="hljs-string">&quot;月租(&quot;</span>+modifyHouse.getRent() +<span class="hljs-string">&quot;):&quot;</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">rent</span>  <span class="hljs-operator">=</span> Utility.readInt(modifyHouse.getRent());<br>    <span class="hljs-keyword">if</span>(modifyHouse.getRent() != rent)&#123;<br>        modifyHouse.setRent(rent);<br>    &#125;<br>    System.out.print(<span class="hljs-string">&quot;状态(&quot;</span>+modifyHouse.getState() +<span class="hljs-string">&quot;):&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> Utility.readString(<span class="hljs-number">8</span>,modifyHouse.getState());<br>    <span class="hljs-keyword">if</span>(!modifyHouse.getState().equals(state))&#123;<br>        modifyHouse.setState(state);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>​    以上就是房屋出租系统的全部内容了, 本项目并非自己独立完成, 在项目许多搞不明白的地方是看着老韩的视频逐步写下来的. 虽然在这个项目上老是磕磕绊绊, 但最终还是完成了. 本来一天的时间就已经足够了的, 因为自己第一天起床晚加上当天晚上又去看迪迦奥特曼, 导致第一天学了3小时多一点. 希望以后在写项目的过程中要合理安排时间. 另外, 在以后还应当提升自己的表达能力, 目前对于问题的分析以及自己想法的陈述还有诸多不足, 希望接下来能一点一点向前进步.</p>]]></content>
    
    
    <categories>
      
      <category>Java项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>房屋出租</tag>
      
      <tag>Java项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>个人博客优化</title>
    <link href="/2022/02/16/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%BC%98%E5%8C%96/"/>
    <url>/2022/02/16/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="个人博客的优化"><a href="#个人博客的优化" class="headerlink" title="个人博客的优化"></a>个人博客的优化</h1><h2 id="1-自动部署"><a href="#1-自动部署" class="headerlink" title="1. 自动部署"></a>1. 自动部署</h2><p>对于个人博客，如果设置为自动部署，每一次发布文章时还需要手动更新 GitHub 仓库中的内容，如果设置为自动部署，那么以后在本地修改博客内容以后便会自动更新 GitHub 中的内容</p><h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><p>首先我们要确保本地 Hexo 是可以正确运行的，比如</p><figure class="highlight crystal"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>hexo clean<br><span class="hljs-variable">$ </span>hexo deploy<br></code></pre></td></tr></table></figure><h3 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h3><p>如果 Hexo 可以正常地部署到 GitHub，那么实际上你原来的秘钥是可以正常使用的。</p><p>以下为 macOS 下的操作，Linux 下操作方法相同，Windows 10 用户可以在市场中安装 Ubuntu 以后执行：</p><h2 id="添加标签页和分类页"><a href="#添加标签页和分类页" class="headerlink" title="添加标签页和分类页"></a>添加标签页和分类页</h2><p>现在使用的主题里打开<code>_config.yml</code>文件（这里一定要是themes文件下所含的主题，不要弄错了）。按下<code>Ctrl+F</code>，搜索<code>menu</code>，找到如下内容：</p><p><img src="C:\Users\Administrator.DESKTOP-VVE6ROJ\AppData\Roaming\Typora\typora-user-images\image-20220216180517037.png" alt="image-20220216180517037"></p><p>按照自己的要求对代码进行修改，让菜单按钮显示出来。</p><p>在blog文件夹下打开 git bash 键入如下命令</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>hexo n page tags<br></code></pre></td></tr></table></figure><p>可以发现在 source  文件夹下出现一个 tags 文件夹，</p><h3 id="文章页"><a href="#文章页" class="headerlink" title="文章页"></a>文章页</h3><h4 id="便签使用"><a href="#便签使用" class="headerlink" title="便签使用"></a>便签使用</h4><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="hljs-template-tag">&#123;% <span class="hljs-name">note</span> success %&#125;</span><span class="language-xml"></span><br><span class="language-xml">文字 或者 `markdown` 均可</span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name">endnote</span> %&#125;</span><br></code></pre></td></tr></table></figure><p>使用时 <div class="note note-primary">            <p>和 </p>          </div> 需单独一行，否则会出现问题</p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>个人博客的搭建</title>
    <link href="/2022/02/16/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <url>/2022/02/16/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<blockquote><p>这是蓝鸟x发布的第一篇文章</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>直接在<code>github page</code>平台上托管我们的博客。这样就可以安心的来写作，又不需要定期维护，而且<code>hexo</code>作为一个快速简洁的博客框架，用它来搭建博客真的非常容易。</p><h2 id="Hexo简介"><a href="#Hexo简介" class="headerlink" title="Hexo简介"></a><code>Hexo</code>简介</h2><p><code>Hexo</code>(中文官方网站)是一个快速, 简洁且高效的博客框架. 让上百个页面在几秒内瞬间完成渲染. <code>Hexo</code>支持<code>Github</code> <code>Flavored</code> <code>Markdown</code>的所有功能, 甚至可以整合<code>Octopress</code>的大多数插件. 并自己也拥有强大的插件系统.</p><h2 id="Hexo-搭建教程"><a href="#Hexo-搭建教程" class="headerlink" title="Hexo 搭建教程"></a><code>Hexo</code> 搭建教程</h2><h6 id="本次教程有-8-个部分，详细介绍了如何搭建个人博客"><a href="#本次教程有-8-个部分，详细介绍了如何搭建个人博客" class="headerlink" title="本次教程有 8 个部分，详细介绍了如何搭建个人博客"></a>本次教程有 8 个部分，详细介绍了如何搭建个人博客</h6><ul><li>安装 <code>Git</code></li><li>安装 <code>Node.js</code></li><li>安装 <code>Hexo</code></li><li><code>Github</code> 创建个人仓库</li><li>更改主题</li><li>发布文章<h3 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 <code>Git</code></h3><blockquote><p>本教程使用的系统是<code>Windows10 Pro</code></p></blockquote></li></ul><p> 到 <a href="https://git-scm.com/download/win">Git</a> 官网下载并安装即可，下载后有一个Git Bash的命令行工具，以后就用这个命令行工具来使用git</p><h3 id="安装-NodeJs"><a href="#安装-NodeJs" class="headerlink" title="安装 NodeJs"></a>安装 <code>NodeJs</code></h3><p> <code>Hexo</code> 是基于 <code>NodeJs</code> 编写的， 因此要安装 <code>nodejs</code> 和里面的工具<code>npm</code>。<br> Windows：<a href="https://nodejs.org/en/download/">下载链接 https://nodejs.org/en/download</a>，选择LTS版本</p><h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 <code>Hexo</code></h3><p>安装好 Git 后，选择好需要安装<code>hexo</code>的地方，这就是你博客的本地服务器（可以新建一个以英文命名的文件夹, 本文建立的文件夹名为 <code>Blog</code>，代指下文出现的<code>Blog</code>），进入这个文件夹后点击空白处，并右键选择 <code>Git Bash here </code> 可以打开 Git 的命令行窗口，输入</p><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ npm install -g hexo-cli<br></code></pre></td></tr></table></figure><p>回车后键入 <code>hexo -v</code> 查看<code>hexo</code>版本</p><h6 id="到这里环境准备完成，开始使用-hexo-搭建个人博客"><a href="#到这里环境准备完成，开始使用-hexo-搭建个人博客" class="headerlink" title="到这里环境准备完成，开始使用 hexo 搭建个人博客"></a>到这里环境准备完成，开始使用 <code>hexo </code>搭建个人博客</h6><h3 id="初始化-Hexo"><a href="#初始化-Hexo" class="headerlink" title="初始化 Hexo"></a>初始化 <code>Hexo</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo init 文件夹名<br>$ <span class="hljs-built_in">cd</span> 文件夹名<br>$ npm install<br></code></pre></td></tr></table></figure><p>这一步之后会在 <code>Blog</code> 文件夹生成许多的文件以及文件夹，以下是相关的英译汉：</p><blockquote><p>node_modules: 依赖包<br>public：存放生成的页面<br>scaffolds：生成文章的一些模板<br>source：用来存放你的文章<br>themes：主题<br>_config.yml: 博客的配置文件</p></blockquote><p>接着输入以下指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo clean<br>$ hexo g<br>$ hexo s<br></code></pre></td></tr></table></figure><p>这里的<code> hexo s</code> 表示打开服务器，如果要关闭服务器，按下<code>ctrl+c</code>即可，打开服务器后可看见如下结果<br><img src="https://img-blog.csdnimg.cn/0afdf4a39f1f436e9149070ae119473c.png" alt="在这里插入图片描述"><br>此时可在浏览器进入 <a href="http://localhost:4000/">http://localhost:4000</a> ，便可看到个人博客的主页。如下图所示：<br><img src="https://img-blog.csdnimg.cn/6f15f2b61af248649695629013d5ca3f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAd2VpeGluXzQ2NjE5OTEy,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="创建-GitHub-仓库"><a href="#创建-GitHub-仓库" class="headerlink" title="创建 GitHub 仓库"></a>创建 <code>GitHub </code>仓库</h3><ol><li><p>首先，需要一个<code>GitHub</code>账户，可通过QQ邮箱注册，这里便不一一赘述了</p></li><li><p>登录<code>GitHub</code>账户后，在个人主页新建仓库，点击<code>New  repository</code><br><img src="https://img-blog.csdnimg.cn/61089a5787e54a47b3fe5eb425495924.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAd2VpeGluXzQ2NjE5OTEy,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>创建一个和你用户名相同的仓库，后面加<code>.github.io</code>，只有这样，将来要部署到<code>GitHub page</code>的时候，才会被识别，也就是<code>xxxx.github.io</code>，其中<code>xxx</code>就是你注册<code>GitHub</code>的用户名。</p><h3 id="生成-SSH-添加到-github-仓库"><a href="#生成-SSH-添加到-github-仓库" class="headerlink" title="生成 SSH 添加到 github 仓库"></a>生成 SSH 添加到 <code>github </code>仓库</h3><p>由于后续都是通过 SSH 进行仓库代码的快速部署，所以这一步很有必要，如果之前有在你的电脑本地进行过你的 github 仓库的 SSH 绑定，那此步可跳过<br>在 Bash 命令行键入以下内容</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;yourname&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;youremail&quot;</span><br></code></pre></td></tr></table></figure><p>yourname就是你的 GitHub 用户名，youremail 就是你注册 GitHub 使用的邮箱。<br>然后键入以下内容，经过多次回车即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ssh-keygen -t rsa -C <span class="hljs-string">&quot;youremail&quot;</span><br></code></pre></td></tr></table></figure><p>这个时候它会告诉你已经生成了.ssh的文件夹。在你的电脑中找到这个文件夹。ssh，简单来讲，就是一个秘钥，其中，id_rsa 是你这台电脑的私人秘钥，不能给别人看的，id_rsa.pub 是公共秘钥，可以随便给别人看。把这个公钥放在 GitHub 上，这样当你链接 GitHub 自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过 git 上传你的文件到 GitHub 上。而后在 github 的 setting 中，找到 SSH keys 的设置选项，点击 New SSH key 把你的 id_rsa.pub 里面的信息复制进去。之后，在 gitbash 中输入以下指令，查看是否 SSH 是否已绑定成功。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ssh -T git@github.com<br></code></pre></td></tr></table></figure><p>成功的界面如下<br><img src="https://img-blog.csdnimg.cn/d63484b3eb6541a385c73fd17585eca2.png" alt="在这里插入图片描述"></p><h3 id="将本地-Hexo-部署到-Github"><a href="#将本地-Hexo-部署到-Github" class="headerlink" title="将本地 Hexo 部署到 Github"></a>将本地 Hexo 部署到 Github</h3><p>这一步，我们就可以将 hexo 和 github 关联起来，也就是将 hexo 生成的文章部署到 github 上，打开站点配置文件 <code>_config.yml</code>，翻到最后，进行如下修改即可，xxxx 改为你的 github 账户用户名</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">deploy:<br>  type: git<br>  repo: git@github.com:xxxx/xxxx.github.io.git<br>  branch: main<br></code></pre></td></tr></table></figure><p>修改完配置文件<code>_config.yml</code>并保存后，回到 gitbash命令行这个时候需要先安装<code>deploy-git</code> ，也就是部署的命令,这样你才能用命令部署到 GitHub</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">hexo clean<br>hexo generate<br>hexo deploy<br></code></pre></td></tr></table></figure><blockquote><p><code>hexo clean</code> 清除了你之前生成的东西。<br><code>hexo generate </code>生成静态文章，可以用 <code>hexo g </code>缩写<br><code>hexo deploy</code> 部署文章，可以用<code>hexo d</code>缩写</p></blockquote><p>部署的时候可能有弹出窗口需要你登录Github，登录即可，设置了 ssh 一般不需要</p><p>得到下图说明你已经部署成功，<br><img src="https://img-blog.csdnimg.cn/692ca13d165d429da904dbe7984a87b6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAd2VpeGluXzQ2NjE5OTEy,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="更改主题"><a href="#更改主题" class="headerlink" title="更改主题"></a>更改主题</h3><p>这里以 fluid 主题作为示例<br>来到主题的 <a href="https://github.com/fluid-dev/hexo-theme-fluid">github</a> 仓库，点击 Download ZIP 下载最新的压缩包<br><img src="https://img-blog.csdnimg.cn/41de292e86b642dfb46f80a64dab1644.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAd2VpeGluXzQ2NjE5OTEy,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>下载完后，将压缩包解压到你博客项目的 themes 文件夹下，并将解压出来文件夹更名为 fluid<br>然后打开根目录的 _config.yml 文件，拉到最下面找到 theme 属性，修改为 fluid<br><img src="https://img-blog.csdnimg.cn/5daa3dc87284453894cea1643c19551e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAd2VpeGluXzQ2NjE5OTEy,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>输入以下三个指令进行重新部署，过一会儿即可看到主题发生改变</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">hexo clean<br>hexo g<br>hexo d<br></code></pre></td></tr></table></figure><h3 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h3><p>发布新文章</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">hexo <span class="hljs-keyword">new</span> newpapername<br></code></pre></td></tr></table></figure><p>然后在Blog&#x2F;source&#x2F;_post中打开markdown文件，就可以开始编辑了。当你写完的时候，再键入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">hexo clean<br>hexo g<br>hexo d<br></code></pre></td></tr></table></figure><p>每次更新完文章或配置，都建议输入以上三个指令进行重新部署，而不要缺某条指令</p><p>以上就是本篇文章的全部内容。</p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客搭建</tag>
      
      <tag>Hi! Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/02/16/hello-world/"/>
    <url>/2022/02/16/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><p><img src="/hello-world.assets/image-20220218160816545.png" alt="image-20220218160816545"></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
